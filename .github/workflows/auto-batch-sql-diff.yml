name: Auto-batch SQL (diff-based)

on:
  push:
    branches: [ main ]
  workflow_dispatch: {}

permissions:
  contents: write
  pull-requests: write

# Prevent two runs from racing the same next number
concurrency:
  group: auto-batch-numbering
  cancel-in-progress: false

env:
  RELEASES_DIR: releases/sql

jobs:
  batch:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout (full history)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Find last batch commit (most recent change in releases/sql)
        id: lastbatch
        run: |
          mkdir -p "$RELEASES_DIR"
          LAST_BATCH_COMMIT=$(git log -1 --format=%H -- "$RELEASES_DIR" || true)
          echo "last=$LAST_BATCH_COMMIT" >> "$GITHUB_OUTPUT"

      - name: Determine changed .sql files since last batch (exclude releases/)
        id: changed
        run: |
          if [ -n "${{ steps.lastbatch.outputs.last }}" ]; then
            git diff --name-only ${{ steps.lastbatch.outputs.last }}..HEAD -- '**/*.sql' \
              | grep -v '^releases/sql/' | sort > changed.txt || true
          else
            # First batch: include all tracked SQLs outside releases/
            git ls-files '**/*.sql' | grep -v '^releases/sql/' | sort > changed.txt || true
          fi
          echo "Changed files:"; cat changed.txt || true

      - name: Check if there is anything to batch
        id: check
        run: |
          if ! [ -s changed.txt ]; then
            echo "No changed .sql files since last batch."
            echo "has_changes=false" >> $GITHUB_OUTPUT
          else
            echo "has_changes=true" >> $GITHUB_OUTPUT
          fi

      - name: Determine next batch number
        if: steps.check.outputs.has_changes == 'true'
        id: next
        run: |
          LAST=$(ls "$RELEASES_DIR" 2>/dev/null | sed -n 's/^\([0-9][0-9][0-9]\)_.*/\1/p' | sort -n | tail -1)
          if [ -z "$LAST" ]; then NEXT=1; else NEXT=$((10#$LAST + 1)); fi
          printf "num=%03d\n" "$NEXT" >> "$GITHUB_OUTPUT"

      # Copy with FLAT layout; if you prefer to preserve subpaths,
      # replace cp "$f" "$BATCH_DIR/$(basename "$f")" with:
      # mkdir -p "$BATCH_DIR/$(dirname "$f")"; cp "$f" "$BATCH_DIR/$f"
      - name: Create batch folder and COPY changed files (flat)
        if: steps.check.outputs.has_changes == 'true'
        id: batch
        run: |
          TS=$(date +%Y%m%d_%H%M)
          BATCH_NAME="${{ steps.next.outputs.num }}_${TS}"
          BATCH_DIR="$RELEASES_DIR/$BATCH_NAME"
          mkdir -p "$BATCH_DIR"
          while IFS= read -r f; do
            [ -z "$f" ] && continue
            cp "$f" "$BATCH_DIR/$(basename "$f")"
          done < changed.txt
          echo "name=$BATCH_NAME" >> "$GITHUB_OUTPUT"
          echo "dir=$BATCH_DIR"   >> "$GITHUB_OUTPUT"
          echo "Created $BATCH_DIR:"; ls -1 "$BATCH_DIR" || true

      - name: Open Pull Request
        if: steps.check.outputs.has_changes == 'true'
        uses: peter-evans/create-pull-request@v6
        with:
          commit-message: "[skip ci] feat(sql): batch ${{ steps.batch.outputs.name }}"
          branch: "batch/${{ steps.batch.outputs.name }}"
          base: main
          title: "SQL Batch ${{ steps.batch.outputs.name }}"
          body: |
            Auto-generated from changed .sql files since the last batch.
            Files copied into `${{ steps.batch.outputs.dir }}`.
          labels: sql
          delete-branch: true
