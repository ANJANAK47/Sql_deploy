name: Auto-batch SQL (concat changed ddl*/dml* with global numbering)

on:
  push:
    branches: [ main ]
  workflow_dispatch: {}

permissions:
  contents: write
  pull-requests: write

concurrency:
  group: auto-batch-numbering
  cancel-in-progress: false

env:
  RELEASES_DIR: releases/sql

jobs:
  batch:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout (full history)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Find last batch commit (most recent change in releases/sql)
        id: lastbatch
        run: |
          mkdir -p "$RELEASES_DIR"
          LAST_BATCH_COMMIT=$(git log -1 --format=%H -- "$RELEASES_DIR" || true)
          echo "last=$LAST_BATCH_COMMIT" >> "$GITHUB_OUTPUT"

      - name: Determine changed ddl*/dml* since last batch (in sql/new/)
        id: changed
        run: |
          set -euo pipefail
          if [ -n "${{ steps.lastbatch.outputs.last }}" ]; then
            git diff --name-only "${{ steps.lastbatch.outputs.last }}"..HEAD -- \
              'sql/new/ddl*.sql' 'sql/new/dml*.sql' | sort > changed.txt || true
          else
            # First batch: treat all existing ddl*/dml* as changed
            git ls-files 'sql/new/ddl*.sql' 'sql/new/dml*.sql' | sort > changed.txt || true
          fi
          echo "Changed files:"
          cat changed.txt || true

      - name: Anything to batch?
        id: check
        run: |
          if ! [ -s changed.txt ]; then
            echo "has_changes=false" >> "$GITHUB_OUTPUT"
            echo "No ddl*/dml* changes."
          else
            echo "has_changes=true" >> "$GITHUB_OUTPUT"
          fi

      - name: Determine next batch number
        if: steps.check.outputs.has_changes == 'true'
        id: nextbatch
        run: |
          LAST=$(ls "$RELEASES_DIR" 2>/dev/null | sed -n 's/^\([0-9][0-9][0-9]\)_.*/\1/p' | sort -n | tail -1)
          if [ -z "$LAST" ]; then NEXT=1; else NEXT=$((10#$LAST + 1)); fi
          printf "num=%03d\n" "$NEXT" >> "$GITHUB_OUTPUT"

      - name: Compute GLOBAL ddl/dml next numbers
        if: steps.check.outputs.has_changes == 'true'
        id: globalnums
        run: |
          DDL_MAX=$(find "$RELEASES_DIR" -type f -name 'ddl*.sql' 2>/dev/null \
            | sed -n 's/.*\/ddl\([0-9][0-9]*\)\.sql$/\1/p' | sort -n | tail -1)
          [ -z "$DDL_MAX" ] && DDL_MAX=0
          echo "ddl_next=$((DDL_MAX+1))" >> "$GITHUB_OUTPUT"

          DML_MAX=$(find "$RELEASES_DIR" -type f -name 'dml*.sql' 2>/dev/null \
            | sed -n 's/.*\/dml\([0-9][0-9]*\)\.sql$/\1/p' | sort -n | tail -1)
          [ -z "$DML_MAX" ] && DML_MAX=0
          echo "dml_next=$((DML_MAX+1))" >> "$GITHUB_OUTPUT"

      - name: Build batch (concat changed ddl*/dml* in numeric order)
        if: steps.check.outputs.has_changes == 'true'
        id: batch
        run: |
          set -euo pipefail
          TS=$(date +%Y%m%d_%H%M)
          BATCH_NAME="${{ steps.nextbatch.outputs.num }}_${TS}"
          BATCH_DIR="$RELEASES_DIR/$BATCH_NAME"
          mkdir -p "$BATCH_DIR/ddl" "$BATCH_DIR/dml"

          DDL_NEXT=${{ steps.globalnums.outputs.ddl_next }}
          DML_NEXT=${{ steps.globalnums.outputs.dml_next }}

          # Extract numbers of changed ddl/dml files safely (no-match friendly)
          DDL_NUMS=$(
            { grep -E '^sql/new/ddl[0-9]+\.sql$' changed.txt || true; } \
            | sed -n 's#^sql/new/ddl\([0-9]\+\)\.sql$#\1#p' \
            | sort -n \
            | xargs
          )

          DML_NUMS=$(
            { grep -E '^sql/new/dml[0-9]+\.sql$' changed.txt || true; } \
            | sed -n 's#^sql/new/dml\([0-9]\+\)\.sql$#\1#p' \
            | sort -n \
            | xargs
          )

          MADE=0

          if [ -n "${DDL_NUMS:-}" ]; then
            OUT="$BATCH_DIR/ddl/ddl${DDL_NEXT}.sql"
            : > "$OUT"
            for n in $DDL_NUMS; do
              SRC="sql/new/ddl${n}.sql"
              [ -f "$SRC" ] || continue
              echo "-- ===== BEGIN ddl${n}.sql =====" >> "$OUT"
              cat "$SRC" >> "$OUT"
              echo -e "\n-- ===== END ddl${n}.sql =====\n" >> "$OUT"
            done
            echo "Created $OUT"
            MADE=1
          fi

          if [ -n "${DML_NUMS:-}" ]; then
            OUT="$BATCH_DIR/dml/dml${DML_NEXT}.sql"
            : > "$OUT"
            for n in $DML_NUMS; do
              SRC="sql/new/dml${n}.sql"
              [ -f "$SRC" ] || continue
              echo "-- ===== BEGIN dml${n}.sql =====" >> "$OUT"
              cat "$SRC" >> "$OUT"
              echo -e "\n-- ===== END dml${n}.sql =====\n" >> "$OUT"
            done
            echo "Created $OUT"
            MADE=1
          fi

          echo "name=$BATCH_NAME" >> "$GITHUB_OUTPUT"
          echo "dir=$BATCH_DIR"   >> "$GITHUB_OUTPUT"
          echo "made=$MADE"       >> "$GITHUB_OUTPUT"

          if [ "$MADE" -eq 1 ]; then
            echo "Batch contents:"
            find "$BATCH_DIR" -type f -name '*.sql' | sort
          else
            echo "No ddl*/dml* changed after filtering."
          fi

      - name: Open Pull Request
        if: steps.batch.outputs.made == '1'
        uses: peter-evans/create-pull-request@v6
        with:
          commit-message: "[skip ci] feat(sql): batch ${{ steps.batch.outputs.name }} (concat changed ddl*/dml*)"
          branch: "batch/${{ steps.batch.outputs.name }}"
          base: main
          title: "SQL Batch ${{ steps.batch.outputs.name }} (concat ddl/dml)"
          body: |
            This batch concatenates **changed** `sql/new/ddlN.sql` and `sql/new/dmlN.sql`
            into single files with **global numbering**:

            - DDL → `${{ steps.batch.outputs.dir }}/ddl/ddl<next>.sql` (changed ddl files in numeric order)
            - DML → `${{ steps.batch.outputs.dir }}/dml/dml<next>.sql` (changed dml files in numeric order)

            Examples:
            - If only `ddl1.sql` changed → new ddl file contains only ddl1
            - If `ddl1.sql` and `ddl2.sql` changed → new ddl file contains ddl1 first, then ddl2
          labels: sql
          delete-branch: true
